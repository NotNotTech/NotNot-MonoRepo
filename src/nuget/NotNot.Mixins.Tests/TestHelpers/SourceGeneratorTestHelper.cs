using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using System.Collections.Immutable;
using System.Reflection;

namespace NotNot.Mixins.Tests.TestHelpers;

/// <summary>
/// Helper for testing InlineComposition source generator.
/// </summary>
public static class SourceGeneratorTestHelper
{
	public const string GENERATED_SOURCE_HEAD = """
		// <auto-generated/>
		#pragma warning disable
		#nullable enable annotations


		using NotNot.MixinsAttributes;

		namespace MyCode;
		""";

	/// <summary>
	/// Runs the InlineComposition generator on the input source and returns generated sources.
	/// </summary>
	public static string[] GenerateSourceText(
		string input,
		out Compilation outputCompilation,
		out ImmutableArray<Diagnostic> diagnostics)
	{
		var generator = new InlineCompositionGenerator();
		GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
		driver = driver.RunGeneratorsAndUpdateCompilation(
			CreateCompilation(input),
			out outputCompilation,
			out diagnostics);

		GeneratorDriverRunResult runResult = driver.GetRunResult();
		if (runResult.Results.Length == 0)
			return [];

		GeneratorRunResult generatorResult = runResult.Results[0];
		return [.. generatorResult.GeneratedSources.Select(gs => gs.SourceText.ToString())];
	}

	/// <summary>
	/// Runs the generator and returns only user-generated sources (excludes attribute definitions).
	/// </summary>
	public static string[] GenerateUserSourceText(
		string input,
		out Compilation outputCompilation,
		out ImmutableArray<Diagnostic> diagnostics)
	{
		var allSources = GenerateSourceText(input, out outputCompilation, out diagnostics);

		// Filter out attribute definition files - keep only actual generated class files
		return allSources
			.Where(s => !s.Contains("internal sealed class InlineAttribute") &&
			           !s.Contains("internal sealed class InlineBaseAttribute") &&
			           !s.Contains("internal sealed class NoInlineAttribute") &&
			           !s.Contains("internal sealed class InlineMethodAttribute") &&
			           !s.Contains("internal sealed class InlineConstructorAttribute") &&
			           !s.Contains("internal sealed class InlineFinalizerAttribute"))
			.ToArray();
	}

	/// <summary>
	/// Runs generator on multiple source files (for cross-assembly simulation).
	/// </summary>
	public static string[] GenerateFromMultipleSources(
		string[] sources,
		out Compilation outputCompilation,
		out ImmutableArray<Diagnostic> diagnostics)
	{
		var generator = new InlineCompositionGenerator();
		GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
		driver = driver.RunGeneratorsAndUpdateCompilation(
			CreateCompilation(sources),
			out outputCompilation,
			out diagnostics);

		GeneratorDriverRunResult runResult = driver.GetRunResult();
		if (runResult.Results.Length == 0)
			return [];

		GeneratorRunResult generatorResult = runResult.Results[0];
		return [.. generatorResult.GeneratedSources.Select(gs => gs.SourceText.ToString())];
	}

	private static CSharpCompilation CreateCompilation(string source)
	{
		return CreateCompilation([source]);
	}

	private static CSharpCompilation CreateCompilation(string[] sources)
	{
		var syntaxTrees = sources.Select(s => CSharpSyntaxTree.ParseText(s)).ToArray();

		var references = new List<MetadataReference>
		{
			MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
		};

		// Add netstandard reference
		var netStandardAssembly = Assembly.Load("netstandard, Version=2.0.0.0");
		references.Add(MetadataReference.CreateFromFile(netStandardAssembly.Location));

		// Add System.Runtime
		var runtimeAssembly = Assembly.Load("System.Runtime");
		references.Add(MetadataReference.CreateFromFile(runtimeAssembly.Location));

		var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);

		return CSharpCompilation.Create("TestCompilation", syntaxTrees, references, compilationOptions);
	}

	/// <summary>
	/// Creates a compilation representing an external assembly (already compiled, no source available).
	/// Returns only the metadata reference, not the source.
	/// </summary>
	public static MetadataReference CreateExternalAssemblyReference(string source, string assemblyName = "ExternalAssembly")
	{
		var syntaxTree = CSharpSyntaxTree.ParseText(source);

		var references = new List<MetadataReference>
		{
			MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
		};

		var netStandardAssembly = Assembly.Load("netstandard, Version=2.0.0.0");
		references.Add(MetadataReference.CreateFromFile(netStandardAssembly.Location));

		var runtimeAssembly = Assembly.Load("System.Runtime");
		references.Add(MetadataReference.CreateFromFile(runtimeAssembly.Location));

		var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);
		var compilation = CSharpCompilation.Create(assemblyName, [syntaxTree], references, compilationOptions);

		using var ms = new MemoryStream();
		var result = compilation.Emit(ms);
		if (!result.Success)
		{
			var errors = string.Join("\n", result.Diagnostics.Where(d => d.Severity == DiagnosticSeverity.Error));
			throw new InvalidOperationException($"Failed to compile external assembly:\n{errors}");
		}

		ms.Seek(0, SeekOrigin.Begin);
		return MetadataReference.CreateFromStream(ms);
	}

	/// <summary>
	/// Runs generator with an external assembly reference (simulates cross-assembly scenario).
	/// </summary>
	public static string[] GenerateWithExternalAssembly(
		string mainSource,
		MetadataReference externalAssemblyRef,
		out Compilation outputCompilation,
		out ImmutableArray<Diagnostic> diagnostics)
	{
		var syntaxTree = CSharpSyntaxTree.ParseText(mainSource);

		var references = new List<MetadataReference>
		{
			MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
			MetadataReference.CreateFromFile(typeof(Binder).Assembly.Location),
			externalAssemblyRef
		};

		var netStandardAssembly = Assembly.Load("netstandard, Version=2.0.0.0");
		references.Add(MetadataReference.CreateFromFile(netStandardAssembly.Location));

		var runtimeAssembly = Assembly.Load("System.Runtime");
		references.Add(MetadataReference.CreateFromFile(runtimeAssembly.Location));

		var compilationOptions = new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary);
		var compilation = CSharpCompilation.Create("TestCompilation", [syntaxTree], references, compilationOptions);

		var generator = new InlineCompositionGenerator();
		GeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
		driver = driver.RunGeneratorsAndUpdateCompilation(
			compilation,
			out outputCompilation,
			out diagnostics);

		GeneratorDriverRunResult runResult = driver.GetRunResult();
		if (runResult.Results.Length == 0)
			return [];

		GeneratorRunResult generatorResult = runResult.Results[0];
		return [.. generatorResult.GeneratedSources.Select(gs => gs.SourceText.ToString())];
	}
}
