using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Http;


namespace NotNot;

/// <summary>
/// wrapper around ProblemDetails to include details we care about
/// </summary>
public record class Problem
{
	///// <summary>
	///// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	///// dereferenced, it provide human-readable documentation for the problem type
	///// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	///// "about:blank".
	///// </summary>

	//[Obsolete("not important?")]
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-5)]
	//[JsonPropertyName("type")]
	//public string? Type { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public HttpStatusCode? Status { get; set; }

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	//[Obsolete("not important?")]
	///// <summary>
	///// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	///// </summary>
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-1)]
	//[JsonPropertyName("instance")]
	//public string? Instance { get; set; }

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	public override string ToString()
	{
		return $"Problem: {category},{Title}. {Detail}";
	}

	/// <summary>
	/// exception thrown by Problem
	/// </summary>
	public class ProblemException : LoLoException
	{
		public ProblemException(Problem problem) : base(problem.Title + ":" + problem.Detail, problem.GetEx())
		{
			Problem = problem;
			Source = problem.source;
		}

		public Problem Problem { get; }
	}

	/// <summary>
	/// general classification of the Problem
	/// </summary>
	public static class CategoryNames
	{
		/// <summary>
		/// data failed validation
		/// </summary>
		public static string Validation => nameof(Validation);
		/// <summary>
		/// a problem with a database operation, ex: a record not found, transaction failure, or a unique constraint violation
		/// </summary>
		public static string DbIo => nameof(DbIo);
		/// <summary>
		/// the call not authenicated / permissions
		/// </summary>
		public static string Auth => nameof(Auth);
		/// <summary>
		/// problem calling a network api, ex: timeout, 404, 500, etc.
		/// </summary>
		public static string NetIo => nameof(NetIo);

		/// <summary>
		/// a timeout occcured, ex: CancellationToken
		/// </summary>
		public static string Timeout => nameof(Timeout);
		public static string Unknown => nameof(Unknown);

		
	}

	public (string memberName, string sourceFilePath, int sourceLineNumber) DecomposeSource()
	{
		var parts = source?.Split('|') ?? new string[0];
		if (parts.Length >= 3 && int.TryParse(parts[2], out int lineNumber))
		{
			return (parts[0], parts[1], lineNumber);
		}
		else
		{
			// Handle the error case where the source format is incorrect
			// You can throw an exception or return a default value based on your requirements
			throw new InvalidOperationException("Invalid source format");
		}
	}
	public Problem([CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		Extensions[nameof(source)] = $"{memberName}|{sourceFilePath}|{sourceLineNumber}";
	}
	public Problem(Problem problemBase, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Status = problemBase.Status;
		Title = problemBase.Title;
		//Type = problemBase.Type;
		Detail = problemBase.Detail;
		//Instance = problemBase.Instance;

		foreach (var pair in problemBase.Extensions)
		{
			Extensions[pair.Key] = pair.Value;
		}
	}

	[SetsRequiredMembers]
	public Problem(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Status = HttpStatusCode.InternalServerError;
		Title = ex.GetType().Name;
		
		category = CategoryNames.Unknown;
		//Type = Problem.CategoryNames.;
		Detail = ex.Message;
		//Instance = ex.Source;

		this.ex = ex;
		//foreach (DictionaryEntry pair in ex.Data)
		//{
		//	Extensions[pair.Key.ToString()] = pair.Value;
	
		//}

		//foreach (var pair in problemBase.Extensions)
		//{
		//	Extensions[pair.Key] = pair.Value;
		//}
	}

	/// <summary>
	/// Convert this problem to an Exception, preserving details.
	/// </summary>
	/// <returns></returns>
	public ProblemException ToException()
	{
		return new ProblemException(this);
	}

	/// <summary>
	/// the callsite (source) of the problem
	/// </summary>
	public string source { get => (string)Extensions[nameof(source)]!; init => Extensions[nameof(source)] = value; }

	public required string category { get => (string)Extensions[nameof(category)]!; init => Extensions[nameof(category)] = value; }

	/// <summary>
	/// useful to hint to upstream callers that a problem is recoverable.
	/// not needed to call to set value as false, as it's redundant.
	/// </summary>
	/// <example>false</example>
	public bool isRecoverable
	{
		get
		{
			if (Extensions.TryGetValue(nameof(isRecoverable), out var result))
			{
				switch (result)
				{
					case bool toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.IsRecoverable is not a bool", result);
						break;
				}
			}
			return false;
		}
		set
		{
			if (value is false)
			{
				Extensions.Remove(nameof(isRecoverable));
			}
			else
			{
				Extensions[nameof(isRecoverable)] = value;
			}
		}
	}
	/// <summary>
	/// only set in DEBUG
	/// </summary>
	public Exception? ex
	{
		get
		{
			if (Extensions.TryGetValue(nameof(ex), out var result))
			{
				switch (result)
				{
					case Exception toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.Ex is not an exception", result);
						break;
				}
			}
			return null;
		}
		set
		{
			if (value is null)
			{
				Extensions.Remove(nameof(ex));
			}
			else
			{
				Extensions[nameof(ex)] = value;
			}
		}
	}

	/// <summary>
	/// Helper to add to the .Extensions dictionary
	/// </summary>
	/// <param name="value"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	/// <param name="key"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	public void SetExtension(object value,[CallerMemberName] string key="")
	{
		Extensions[key] = value;
	}


	public Exception? GetEx()
	{
		return ex as Exception;
	}

	public static Problem From(CancellationToken ct, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		if(ct.IsCancellationRequested is false)
		{
			throw new Exception("ct not cancelled");
		}

		return new Problem(memberName, sourceFilePath, sourceLineNumber)
		{
			Title = "CancellationToken cancel requested",
			Detail = "cancellation requested",
			Status = HttpStatusCode.RequestTimeout,
			category = CategoryNames.Timeout,
		};
	}

	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFrom(bool validCondition,[NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("validCondition")] string conditionArgumentName="")
	{
		if (validCondition is false)
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{conditionArgumentName}' is false.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}
	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFromNotEmpty(string value, [NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("value")] string valueName = "")
	{
		if (value._IsNullOrWhiteSpace())
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{valueName}' is empty.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}





	public static Problem From(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		var toReturn = new Problem(ex, memberName, sourceFilePath, sourceLineNumber);
		return toReturn;
	}

}
