using System.Collections;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Http;


namespace NotNot;

/// <summary>
/// wrapper around ProblemDetails to include details we care about
/// </summary>
[JsonConverter(typeof(ProblemJsonConverterFactory))]
public record class Problem
{
	///// <summary>
	///// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	///// dereferenced, it provide human-readable documentation for the problem type
	///// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	///// "about:blank".
	///// </summary>

	//[Obsolete("not important?")]
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-5)]
	//[JsonPropertyName("type")]
	//public string? Type { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public required HttpStatusCode Status { get; set; }

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	/// <summary>
	/// sometimes a problem may be handled (attempt to recover).  If so and the recovery failed, this would be the original problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-1)]
	[JsonPropertyName("innerProblem")]
	public Problem? InnerProblem { get; set; }






	//[Obsolete("not important?")]
	///// <summary>
	///// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	///// </summary>
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-1)]
	//[JsonPropertyName("instance")]
	//public string? Instance { get; set; }

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	public override string ToString()
	{
		return $"Problem: {category},{Title}. {Detail}";
	}

	/// <summary>
	/// exception thrown by Problem
	/// </summary>
	public class ProblemException : LoLoException
	{
		public ProblemException(Problem problem) : base(problem.Title + ":" + problem.Detail, problem.GetEx())
		{
			Problem = problem;
			Source = problem.source;
		}

		public Problem Problem { get; }
	}

	/// <summary>
	/// general classification of the Problem
	/// </summary>
	public static class CategoryNames
	{
		/// <summary>
		/// data failed validation
		/// </summary>
		public static string Validation => nameof(Validation);
		/// <summary>
		/// a problem with a database operation, ex: a record not found, transaction failure, or a unique constraint violation
		/// </summary>
		public static string DbIo => nameof(DbIo);
		/// <summary>
		/// the call not authenicated / permissions
		/// </summary>
		public static string Auth => nameof(Auth);
		/// <summary>
		/// problem calling a network api, ex: timeout, 404, 500, etc.
		/// </summary>
		public static string NetIo => nameof(NetIo);

		/// <summary>
		/// a timeout occcured, ex: CancellationToken
		/// </summary>
		public static string Timeout => nameof(Timeout);
		public static string Unknown => nameof(Unknown);


	}

	public Problem([CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		Extensions[nameof(source)] = $"{memberName}|{sourceFilePath}|{sourceLineNumber}";
	}
	public Problem(Problem problemBase, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Status = problemBase.Status;
		Title = problemBase.Title;
		//Type = problemBase.Type;
		Detail = problemBase.Detail;
		//Instance = problemBase.Instance;

		foreach (var pair in problemBase.Extensions)
		{
			Extensions[pair.Key] = pair.Value;
		}
	}

	[SetsRequiredMembers]
	public Problem(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Title = ex.GetType().Name;

		category = CategoryNames.Unknown;
		//Type = Problem.CategoryNames.;
		Detail = ex.Message;
		//Instance = ex.Source;

		this.Ex = ex;
		//foreach (DictionaryEntry pair in ex.Data)
		//{
		//	Extensions[pair.Key.ToString()] = pair.Value;

		//}

		//foreach (var pair in problemBase.Extensions)
		//{
		//	Extensions[pair.Key] = pair.Value;
		//}

		//compute default status from exception type
		switch (ex)
		{
			case UnauthorizedAccessException:
				Status = HttpStatusCode.Unauthorized;
				break;
			default:
				Status = HttpStatusCode.InternalServerError;
				break;
		}


	}

	public (string memberName, string sourceFilePath, int sourceLineNumber) DecomposeSource()
	{
		var parts = source?.Split('|') ?? new string[0];
		if (parts.Length >= 3 && int.TryParse(parts[2], out int lineNumber))
		{
			return (parts[0], parts[1], lineNumber);
		}
		else
		{
			// Handle the error case where the source format is incorrect
			// You can throw an exception or return a default value based on your requirements
			throw new InvalidOperationException("Invalid source format");
		}
	}

	/// <summary>
	/// obtain the root exception or Problem that triggered the problem chain.
	/// <para>If an exception, it's inner-most exception will be returned along with the inner most Problem's location.</para>
	/// </summary>
	/// <remarks>not using ex source because it doesn't roundtrip over HTTP (will be blank)</remarks>
	/// <returns></returns>
	public Problem GetRootCause()
	{
		if (InnerProblem is not null)
		{
			return InnerProblem.GetRootCause();
		}
		else if (Ex is not null)
		{
			var ex = Ex;
			while (ex.InnerException is not null)
			{
				ex = ex.InnerException;
			}
			ex = ex.GetBaseException();

			//get the source location of the inner most Problem that carried the innerException
			var (sourceMember, sourceFilePath, sourceLineNumber) = this.DecomposeSource();// ex._DecomposeSource(); //VIBEGUIDE: 

			return FromEx(ex, sourceMember, sourceFilePath, sourceLineNumber);
		}
		else
		{
			return this;
		}

	}


	/// <summary>
	/// Convert this problem to an Exception, preserving details.
	/// </summary>
	/// <returns></returns>
	public ProblemException ToException()
	{
		return new ProblemException(this);
	}

	/// <summary>
	/// the callsite (source) of the problem
	/// </summary>
	public string source { get => (string)Extensions[nameof(source)]!; init => Extensions[nameof(source)] = value; }

	public required string category { get => (string)Extensions[nameof(category)]!; init => Extensions[nameof(category)] = value; }

	/// <summary>
	/// useful to hint to upstream callers that a problem is recoverable.
	/// not needed to call to set value as false, as it's redundant.
	/// </summary>
	/// <example>false</example>
	public bool isRecoverable
	{
		get
		{
			if (Extensions.TryGetValue(nameof(isRecoverable), out var result))
			{
				switch (result)
				{
					case bool toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.IsRecoverable is not a bool", result);
						break;
				}
			}
			return false;
		}
		set
		{
			if (value is false)
			{
				Extensions.Remove(nameof(isRecoverable));
			}
			else
			{
				Extensions[nameof(isRecoverable)] = value;
			}
		}
	}
	/// <summary>
	/// only set in DEBUG
	/// </summary>
	public Exception? Ex
	{
		get
		{
			if (Extensions.TryGetValue(nameof(Ex).ToLowerInvariant(), out var result))
			{
				switch (result)
				{
					case Exception toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.Ex is not an exception", result);
						break;
				}
			}
			return null;
		}
		set
		{
			if (value is null)
			{
				Extensions.Remove(nameof(Ex).ToLowerInvariant());
			}
			else
			{
				Extensions[nameof(Ex).ToLowerInvariant()] = value;
			}
		}
	}

	/// <summary>
	/// Helper to add to the .Extensions dictionary
	/// </summary>
	/// <param name="value"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	/// <param name="key"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	public void SetExtension(object value, [CallerMemberName] string key = "")
	{
		Extensions[key] = value;
	}


	public Exception? GetEx()
	{
		return Ex as Exception;
	}

	public static Problem FromCancelledToken(CancellationToken ct, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		if (ct.IsCancellationRequested is false)
		{
			throw new Exception("ct not cancelled");
		}

		return new Problem(memberName, sourceFilePath, sourceLineNumber)
		{
			Title = "CancellationToken cancel requested",
			Detail = "cancellation requested",
			Status = HttpStatusCode.RequestTimeout,
			category = CategoryNames.Timeout,
		};
	}

	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFrom(bool validCondition, [NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("validCondition")] string conditionArgumentName = "")
	{
		if (validCondition is false)
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{conditionArgumentName}' is false.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}
	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFromNotEmpty(string value, [NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("value")] string valueName = "")
	{
		if (value._IsNullOrWhiteSpace())
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{valueName}' is empty.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}

	public static Problem FromEx(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		var toReturn = new Problem(ex, memberName, sourceFilePath, sourceLineNumber);
		return toReturn;
	}

}



/// <summary>
/// a problem that may be retried, needs custom handling at the callsite
/// </summary>
public record class RetryProblem : Problem
{
	public required int RetryCount
	{
		get => Extensions._GetOrDefault<int>("RetryCount");
		set => Extensions["RetryCount"] = value;
	}
}



/// <summary>
/// JSON converter for Problem to support deserialization
/// </summary>
public class ProblemJsonConverterFactory : JsonConverterFactory
{
	public override bool CanConvert(Type typeToConvert)
	{
		return typeToConvert == typeof(Problem);
	}

	public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
	{
		return (JsonConverter)Activator.CreateInstance(typeof(ProblemJsonConverter))!;
	}
}

/// <summary>
/// Typed JSON converter for Problem
/// </summary>
public class ProblemJsonConverter : JsonConverter<Problem>
{
	private static void SerializeException(Utf8JsonWriter writer, Exception exception)
	{
		writer.WriteStartObject();
		writer.WriteString("__type", "Exception");
		writer.WriteString("typeName", exception.GetType().FullName);
		writer.WriteString("message", exception.Message);
		//source and stackTrace doesn't roundtrip
		//writer.WriteString("stackTrace", exception.StackTrace);
		//writer.WriteString("source", exception.Source);
		if (exception.InnerException != null)
		{
			writer.WritePropertyName("innerException");
			SerializeException(writer, exception.InnerException);
		}
		writer.WriteEndObject();
	}

	private static Exception? DeserializeException(JsonElement element)
	{
		if (!element.TryGetProperty("__type", out var typeProperty) ||
			typeProperty.GetString() != "Exception")
		{
			return null;
		}

		var typeName = element.TryGetProperty("typeName", out var typeNameProp) ? typeNameProp.GetString() : null;
		var message = element.TryGetProperty("message", out var messageProp) ? messageProp.GetString() : "Deserialized exception";
		//source and stackTrace doesn't roundtrip
		//var stackTrace = element.TryGetProperty("stackTrace", out var stackProp) ? stackProp.GetString() : null;
		//var source = element.TryGetProperty("source", out var sourceProp) ? sourceProp.GetString() : null;

		Exception? innerException = null;
		if (element.TryGetProperty("innerException", out var innerProp))
		{
			innerException = DeserializeException(innerProp);
		}

		// Create a generic exception with the preserved information
		var exception = innerException != null ? new Exception(message, innerException) : new Exception(message);

		//// Use reflection to set the stack trace and source if possible
		//try
		//{
		//	if (stackTrace != null)
		//	{
		//		var stackTraceField = typeof(Exception).GetField("_stackTraceString", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
		//		stackTraceField?.SetValue(exception, stackTrace);
		//	}
		//	if (source != null)
		//	{
		//		exception.Source = source;
		//	}
		//}
		//catch
		//{
		//	// Ignore reflection errors - the core message and inner exception are preserved
		//}

		return exception;
	}
	public override Problem? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		if (reader.TokenType != JsonTokenType.StartObject)
		{
			throw new JsonException("Expected StartObject token");
		}

		string? title = null;
		HttpStatusCode status = HttpStatusCode.InternalServerError;
		string? detail = null;
		string? sourceValue = null; // Renamed to avoid conflict with 'source' variable in Problem
		string? categoryValue = null; // Renamed to avoid conflict
		IDictionary<string, object?> extensions = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);

		while (reader.Read())
		{
			if (reader.TokenType == JsonTokenType.EndObject)
			{
				if (categoryValue == null)
				{
					// Attempt to get category from extensions if it was put there by default handling
					if (extensions.TryGetValue("category", out var catObj) && catObj is string catStr)
					{
						categoryValue = catStr;
					}
					else
					{
						throw new JsonException("Required property 'category' is missing or not a string.");
					}
				}

				string tempSourceForDefaultProblem = new Problem { category = categoryValue, Status = status }.source; // Create a temporary problem to get default source

				// Initialize Problem with required category and potentially source from JSON
				var problem = new Problem() // Default constructor sets a default source
				{
					Title = title,
					Status = status,
					Detail = detail,
					category = categoryValue, // This is required
													  // If sourceValue was read from JSON, it will be used to initialize the source property.
													  // Otherwise, the default source from the Problem constructor remains.
					source = sourceValue ?? tempSourceForDefaultProblem // Use deserialized source if available, else default
				};

				// Apply other deserialized extensions
				foreach (var ext in extensions)
				{
					// Skip source and category as they are handled by init setters or already set
					if (ext.Key.Equals("source", StringComparison.OrdinalIgnoreCase) ||
						 ext.Key.Equals("category", StringComparison.OrdinalIgnoreCase))
					{
						continue;
					}
					problem.Extensions[ext.Key] = ext.Value;
				}

				return problem;
			}

			if (reader.TokenType == JsonTokenType.PropertyName)
			{
				string? propertyName = reader.GetString();
				reader.Read(); // Move to the property value

				switch (propertyName?.ToLowerInvariant())
				{
					case "title":
						title = reader.GetString();
						break;
					case "status":
						if (reader.TokenType == JsonTokenType.Number)
						{
							status = (HttpStatusCode)reader.GetInt32();
						}
						else if (reader.TokenType == JsonTokenType.String)
						{
							if (Enum.TryParse<HttpStatusCode>(reader.GetString(), true, out var parsedStatus))
							{
								status = parsedStatus;
							}
						}
						break;
					case "detail":
						detail = reader.GetString();
						break;
					case "source":
						sourceValue = reader.GetString();
						break;
					case "category":
						categoryValue = reader.GetString();
						break;
					default:
						// Deserialize into extensions dictionary
						if (propertyName != null)
						{
							// Using JsonElement allows to defer parsing of complex extension values if necessary
							var value = JsonSerializer.Deserialize<JsonElement>(ref reader, options);

							// Check if this is a serialized Exception object
							if (value.ValueKind == JsonValueKind.Object)
							{
								var deserializedException = DeserializeException(value);
								if (deserializedException != null)
								{
									extensions[propertyName] = deserializedException;
									break;
								}
							}

							extensions[propertyName] = value.ValueKind switch
							{
								JsonValueKind.String => value.GetString(),
								JsonValueKind.Number => value.GetDouble(), // Or GetInt32, GetInt64 etc. based on expected types
								JsonValueKind.True => true,
								JsonValueKind.False => false,
								JsonValueKind.Null => null,
								JsonValueKind.Object => value.Clone(), // Clone to allow multiple reads or keep as JsonElement
								JsonValueKind.Array => value.Clone(),  // Clone to allow multiple reads or keep as JsonElement
								_ => value.ToString() // Fallback for other types
							};
						}
						break;
				}
			}
		}
		throw new JsonException("Unexpected end of JSON.");
	}

	public override void Write(Utf8JsonWriter writer, Problem value, JsonSerializerOptions options)
	{
		writer.WriteStartObject();

		if (value.Title != null)
		{
			writer.WriteString("title", value.Title);
		}
		//if (value.Status.HasValue)
		{
			writer.WriteNumber("status", (int)value.Status);
		}
		if (value.Detail != null)
		{
			writer.WriteString("detail", value.Detail);
		}

		writer.WriteString("category", value.category); // category is required
																		// source is an extension, but often treated as a primary property in logs/output
																		// The Problem record ensures 'source' is in Extensions via its constructor.
																		// We explicitly write it for clarity, though JsonExtensionData would also pick it up.
		writer.WriteString("source", value.source);


		foreach (var extension in value.Extensions)
		{
			// Avoid re-serializing 'source' and 'category' if they are in extensions,
			// as we've handled them as top-level properties for serialization.
			if (extension.Key.Equals("source", StringComparison.OrdinalIgnoreCase) ||
				extension.Key.Equals("category", StringComparison.OrdinalIgnoreCase))
			{
				continue;
			}
			//write key
			writer.WritePropertyName(extension.Key);
			//write value
			try
			{
				// Special handling for Exception objects to enable round-tripping
				if (extension.Value is Exception exception)
				{
					SerializeException(writer, exception);
				}
				else
				{
					//roundtrip in case errors, which would cause the entire write to fail if we did it directly on the `writer` object.
					var poco = __.SerializationHelper.ToLogPoCo(extension.Value);
					JsonSerializer.Serialize(writer, poco, __.SerializationHelper._logJsonOptions);
				}
			}
			catch (Exception ex)
			{
				writer.WriteStringValue($"ERROR_SERIALIZING:{ex.Message}");
			}
		}

		writer.WriteEndObject();
	}
}
