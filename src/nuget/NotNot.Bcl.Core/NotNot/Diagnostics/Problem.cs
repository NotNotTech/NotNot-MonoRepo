using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Http;


namespace NotNot;

/// <summary>
/// wrapper around ProblemDetails to include details we care about
/// </summary>
[JsonConverter(typeof(ProblemJsonConverterFactory))]
public record class Problem
{
	///// <summary>
	///// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
	///// dereferenced, it provide human-readable documentation for the problem type
	///// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
	///// "about:blank".
	///// </summary>

	//[Obsolete("not important?")]
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-5)]
	//[JsonPropertyName("type")]
	//public string? Type { get; set; }

	/// <summary>
	/// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
	/// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
	/// see[RFC7231], Section 3.4).
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-4)]
	[JsonPropertyName("title")]
	public string? Title { get; set; }

	/// <summary>
	/// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-3)]
	[JsonPropertyName("status")]
	public HttpStatusCode? Status { get; set; }

	/// <summary>
	/// A human-readable explanation specific to this occurrence of the problem.
	/// </summary>
	[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	[JsonPropertyOrder(-2)]
	[JsonPropertyName("detail")]
	public string? Detail { get; set; }

	//[Obsolete("not important?")]
	///// <summary>
	///// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
	///// </summary>
	//[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
	//[JsonPropertyOrder(-1)]
	//[JsonPropertyName("instance")]
	//public string? Instance { get; set; }

	/// <summary>
	/// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
	/// <para>
	/// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
	/// other members of a problem type.
	/// </para>
	/// </summary>
	/// <remarks>
	/// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
	/// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
	/// </remarks>
	[JsonExtensionData]
	public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);

	public override string ToString()
	{
		return $"Problem: {category},{Title}. {Detail}";
	}

	/// <summary>
	/// exception thrown by Problem
	/// </summary>
	public class ProblemException : LoLoException
	{
		public ProblemException(Problem problem) : base(problem.Title + ":" + problem.Detail, problem.GetEx())
		{
			Problem = problem;
			Source = problem.source;
		}

		public Problem Problem { get; }
	}

	/// <summary>
	/// general classification of the Problem
	/// </summary>
	public static class CategoryNames
	{
		/// <summary>
		/// data failed validation
		/// </summary>
		public static string Validation => nameof(Validation);
		/// <summary>
		/// a problem with a database operation, ex: a record not found, transaction failure, or a unique constraint violation
		/// </summary>
		public static string DbIo => nameof(DbIo);
		/// <summary>
		/// the call not authenicated / permissions
		/// </summary>
		public static string Auth => nameof(Auth);
		/// <summary>
		/// problem calling a network api, ex: timeout, 404, 500, etc.
		/// </summary>
		public static string NetIo => nameof(NetIo);

		/// <summary>
		/// a timeout occcured, ex: CancellationToken
		/// </summary>
		public static string Timeout => nameof(Timeout);
		public static string Unknown => nameof(Unknown);

		
	}

	public (string memberName, string sourceFilePath, int sourceLineNumber) DecomposeSource()
	{
		var parts = source?.Split('|') ?? new string[0];
		if (parts.Length >= 3 && int.TryParse(parts[2], out int lineNumber))
		{
			return (parts[0], parts[1], lineNumber);
		}
		else
		{
			// Handle the error case where the source format is incorrect
			// You can throw an exception or return a default value based on your requirements
			throw new InvalidOperationException("Invalid source format");
		}
	}
	public Problem([CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		Extensions[nameof(source)] = $"{memberName}|{sourceFilePath}|{sourceLineNumber}";
	}
	public Problem(Problem problemBase, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Status = problemBase.Status;
		Title = problemBase.Title;
		//Type = problemBase.Type;
		Detail = problemBase.Detail;
		//Instance = problemBase.Instance;

		foreach (var pair in problemBase.Extensions)
		{
			Extensions[pair.Key] = pair.Value;
		}
	}

	[SetsRequiredMembers]
	public Problem(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0) : this(memberName, sourceFilePath, sourceLineNumber)
	{
		Status = HttpStatusCode.InternalServerError;
		Title = ex.GetType().Name;
		
		category = CategoryNames.Unknown;
		//Type = Problem.CategoryNames.;
		Detail = ex.Message;
		//Instance = ex.Source;

		this.ex = ex;
		//foreach (DictionaryEntry pair in ex.Data)
		//{
		//	Extensions[pair.Key.ToString()] = pair.Value;
	
		//}

		//foreach (var pair in problemBase.Extensions)
		//{
		//	Extensions[pair.Key] = pair.Value;
		//}
	}

	/// <summary>
	/// Convert this problem to an Exception, preserving details.
	/// </summary>
	/// <returns></returns>
	public ProblemException ToException()
	{
		return new ProblemException(this);
	}

	/// <summary>
	/// the callsite (source) of the problem
	/// </summary>
	public string source { get => (string)Extensions[nameof(source)]!; init => Extensions[nameof(source)] = value; }

	public required string category { get => (string)Extensions[nameof(category)]!; init => Extensions[nameof(category)] = value; }

	/// <summary>
	/// useful to hint to upstream callers that a problem is recoverable.
	/// not needed to call to set value as false, as it's redundant.
	/// </summary>
	/// <example>false</example>
	public bool isRecoverable
	{
		get
		{
			if (Extensions.TryGetValue(nameof(isRecoverable), out var result))
			{
				switch (result)
				{
					case bool toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.IsRecoverable is not a bool", result);
						break;
				}
			}
			return false;
		}
		set
		{
			if (value is false)
			{
				Extensions.Remove(nameof(isRecoverable));
			}
			else
			{
				Extensions[nameof(isRecoverable)] = value;
			}
		}
	}
	/// <summary>
	/// only set in DEBUG
	/// </summary>
	public Exception? ex
	{
		get
		{
			if (Extensions.TryGetValue(nameof(ex), out var result))
			{
				switch (result)
				{
					case Exception toReturn:
						return toReturn;
					default:
						__.GetLogger()._EzError("problem.Ex is not an exception", result);
						break;
				}
			}
			return null;
		}
		set
		{
			if (value is null)
			{
				Extensions.Remove(nameof(ex));
			}
			else
			{
				Extensions[nameof(ex)] = value;
			}
		}
	}

	/// <summary>
	/// Helper to add to the .Extensions dictionary
	/// </summary>
	/// <param name="value"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	/// <param name="key"><para>If you don't provide a key, the current variable-name of the `value` will be used</para></param>
	public void SetExtension(object value,[CallerMemberName] string key="")
	{
		Extensions[key] = value;
	}


	public Exception? GetEx()
	{
		return ex as Exception;
	}

	public static Problem From(CancellationToken ct, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		if(ct.IsCancellationRequested is false)
		{
			throw new Exception("ct not cancelled");
		}

		return new Problem(memberName, sourceFilePath, sourceLineNumber)
		{
			Title = "CancellationToken cancel requested",
			Detail = "cancellation requested",
			Status = HttpStatusCode.RequestTimeout,
			category = CategoryNames.Timeout,
		};
	}

	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFrom(bool validCondition,[NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("validCondition")] string conditionArgumentName="")
	{
		if (validCondition is false)
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{conditionArgumentName}' is false.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}
	/// <summary>
	/// helper to create a problem if the condition ends up being false.
	/// <para>the condition statement will be used as the problem.detail.  it's not pretty for users, but it's convenient for development.</para>
	/// </summary>
	public static bool TryFromNotEmpty(string value, [NotNullWhen(true)] out Problem? problem, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0,
		[CallerArgumentExpression("value")] string valueName = "")
	{
		if (value._IsNullOrWhiteSpace())
		{
			problem = new Problem(memberName: memberName, sourceFilePath: sourceFilePath, sourceLineNumber: sourceLineNumber)
			{
				category = Problem.CategoryNames.Validation,
				Detail = $"'{valueName}' is empty.",
				Status = HttpStatusCode.BadRequest,
				Title = "FailedCondition",
			};
			return true;
		}
		else
		{
			problem = null;
			return false;
		}

	}

	public static Problem From(Exception ex, [CallerMemberName] string memberName = "",
		[CallerFilePath] string sourceFilePath = "",
		[CallerLineNumber] int sourceLineNumber = 0)
	{
		var toReturn = new Problem(ex, memberName, sourceFilePath, sourceLineNumber);
		return toReturn;
	}

}

/// <summary>
/// JSON converter for Problem to support deserialization
/// </summary>
public class ProblemJsonConverterFactory : JsonConverterFactory
{
	public override bool CanConvert(Type typeToConvert)
	{
		return typeToConvert == typeof(Problem);
	}

	public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
	{
		return (JsonConverter)Activator.CreateInstance(typeof(ProblemJsonConverter))!;
	}
}

/// <summary>
/// Typed JSON converter for Problem
/// </summary>
public class ProblemJsonConverter : JsonConverter<Problem>
{
	public override Problem? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
	{
		if (reader.TokenType != JsonTokenType.StartObject)
		{
			throw new JsonException("Expected StartObject token");
		}

		string? title = null;
		HttpStatusCode? status = null;
		string? detail = null;
		string? sourceValue = null; // Renamed to avoid conflict with 'source' variable in Problem
		string? categoryValue = null; // Renamed to avoid conflict
		IDictionary<string, object?> extensions = new Dictionary<string, object?>(StringComparer.OrdinalIgnoreCase);

		while (reader.Read())
		{
			if (reader.TokenType == JsonTokenType.EndObject)
			{
				if (categoryValue == null)
				{
					// Attempt to get category from extensions if it was put there by default handling
					if (extensions.TryGetValue("category", out var catObj) && catObj is string catStr) {
						categoryValue = catStr;
					} else {
						throw new JsonException("Required property 'category' is missing or not a string.");
					}
				}
				
				string tempSourceForDefaultProblem = new Problem{ category = categoryValue }.source; // Create a temporary problem to get default source
				
				// Initialize Problem with required category and potentially source from JSON
				var problem = new Problem() // Default constructor sets a default source
				{
					Title = title,
					Status = status,
					Detail = detail,
					category = categoryValue, // This is required
					// If sourceValue was read from JSON, it will be used to initialize the source property.
					// Otherwise, the default source from the Problem constructor remains.
					source = sourceValue ?? tempSourceForDefaultProblem // Use deserialized source if available, else default
				};

				// Apply other deserialized extensions
				foreach (var ext in extensions)
				{
					// Skip source and category as they are handled by init setters or already set
					if (ext.Key.Equals("source", StringComparison.OrdinalIgnoreCase) ||
						ext.Key.Equals("category", StringComparison.OrdinalIgnoreCase))
					{
						continue;
					}
					problem.Extensions[ext.Key] = ext.Value;
				}

				return problem;
			}

			if (reader.TokenType == JsonTokenType.PropertyName)
			{
				string? propertyName = reader.GetString();
				reader.Read(); // Move to the property value

				switch (propertyName?.ToLowerInvariant())
				{
					case "title":
						title = reader.GetString();
						break;
					case "status":
						if (reader.TokenType == JsonTokenType.Number)
						{
							status = (HttpStatusCode)reader.GetInt32();
						}
						else if (reader.TokenType == JsonTokenType.String)
						{
							if (Enum.TryParse<HttpStatusCode>(reader.GetString(), true, out var parsedStatus))
							{
								status = parsedStatus;
								}
						}
						break;
					case "detail":
						detail = reader.GetString();
						break;
					case "source":
						sourceValue = reader.GetString();
						break;
					case "category":
						categoryValue = reader.GetString();
						break;
					default:
						// Deserialize into extensions dictionary
						if (propertyName != null)
						{
							// Using JsonElement allows to defer parsing of complex extension values if necessary
							var value = JsonSerializer.Deserialize<JsonElement>(ref reader, options);
							extensions[propertyName] = value.ValueKind switch
							{
								JsonValueKind.String => value.GetString(),
								JsonValueKind.Number => value.GetDouble(), // Or GetInt32, GetInt64 etc. based on expected types
								JsonValueKind.True => true,
								JsonValueKind.False => false,
								JsonValueKind.Null => null,
								JsonValueKind.Object => value.Clone(), // Clone to allow multiple reads or keep as JsonElement
								JsonValueKind.Array => value.Clone(),  // Clone to allow multiple reads or keep as JsonElement
								_ => value.ToString() // Fallback for other types
							};
						}
						break;
				}
			}
		}
		throw new JsonException("Unexpected end of JSON.");
	}

	public override void Write(Utf8JsonWriter writer, Problem value, JsonSerializerOptions options)
	{
		writer.WriteStartObject();

		if (value.Title != null)
		{
			writer.WriteString("title", value.Title);
		}
		if (value.Status.HasValue)
		{
			writer.WriteNumber("status", (int)value.Status.Value);
		}
		if (value.Detail != null)
		{
			writer.WriteString("detail", value.Detail);
		}
		
		writer.WriteString("category", value.category); // category is required
		// source is an extension, but often treated as a primary property in logs/output
		// The Problem record ensures 'source' is in Extensions via its constructor.
		// We explicitly write it for clarity, though JsonExtensionData would also pick it up.
		writer.WriteString("source", value.source);


	   foreach (var extension in value.Extensions)
	   {
		   // Avoid re-serializing 'source' and 'category' if they are in extensions,
		   // as we've handled them as top-level properties for serialization.
		   if (extension.Key.Equals("source", StringComparison.OrdinalIgnoreCase) || 
			   extension.Key.Equals("category", StringComparison.OrdinalIgnoreCase))
		   {
			   continue;
		   }
		   writer.WritePropertyName(extension.Key);
		   // Always serialize extension values using the log serialization options for safety
		   string logJson = NotNot.Serialization.SerializationHelper.ToJson_Log(extension.Value);
		   using (var doc = System.Text.Json.JsonDocument.Parse(logJson))
		   {
			   doc.RootElement.WriteTo(writer);
		   }
	   }

		writer.WriteEndObject();
	}
}
